// Code generated by cyamli, DO NOT EDIT.
package main

import (
	"fmt"
	"strconv"
	"strings"
)

type CLIHandler interface {
	Run(input Input) error
	Run_Build(input Input_Build) error
	Run_Rewrite(input Input_Rewrite) error
	Run_Run(input Input_Run) error
}

func Run(handler CLIHandler, args []string) error {
	subcommandPath, options, arguments := resolveArgs(args)
	switch strings.Join(subcommandPath, " ") {
	case "":
		var input Input
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run(input)

	case "build":
		var input Input_Build
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Build(input)

	case "rewrite":
		var input Input_Rewrite
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Rewrite(input)

	case "run":
		var input Input_Run
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Run(input)
	}
	return nil
}

type Input struct {
	Subcommand []string
	Options    []string
	Arguments  []string

	ErrorMessage string
}

func (input *Input) resolveInput(subcommand, options, arguments []string) {
	*input = Input{Subcommand: subcommand,
		Options:   options,
		Arguments: arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_Build struct {
	Opt_GoBuildArgs string
	Arg_Package     []string
	Subcommand      []string
	Options         []string
	Arguments       []string

	ErrorMessage string
}

func (input *Input_Build) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Build{Opt_GoBuildArgs: "",
		Subcommand: subcommand,
		Options:    options,
		Arguments:  arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-go-build-args", "-a":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_GoBuildArgs = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_Package = v.([]string)
	}
}

type Input_Rewrite struct {
	Opt_OutputDirectory string
	Arg_Package         []string
	Subcommand          []string
	Options             []string
	Arguments           []string

	ErrorMessage string
}

func (input *Input_Rewrite) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Rewrite{Opt_OutputDirectory: "",
		Subcommand: subcommand,
		Options:    options,
		Arguments:  arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-output-directory", "-o":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutputDirectory = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_Package = v.([]string)
	}
}

type Input_Run struct {
	Opt_GoRunArgs           string
	Arg_PackageAndArguments []string
	Subcommand              []string
	Options                 []string
	Arguments               []string

	ErrorMessage string
}

func (input *Input_Run) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Run{Opt_GoRunArgs: "",
		Subcommand: subcommand,
		Options:    options,
		Arguments:  arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-go-run-args":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_GoRunArgs = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_PackageAndArguments = v.([]string)
	}
}
func resolveArgs(args []string) (subcommandPath []string, options []string, arguments []string) {
	if len(args) == 0 {
		panic("command line arguments are too few")
	}
	subcommandSet := map[string]bool{
		"": true, "build": true, "rewrite": true, "run": true,
	}

	subcommandPath, options, arguments = []string{}, []string{}, []string{}
	for _, arg := range args[1:] {
		if arg == "--" {
			break
		}
		pathLiteral := strings.Join(append(append([]string{}, subcommandPath...), arg), " ")
		if !subcommandSet[pathLiteral] {
			break
		}
		subcommandPath = append(subcommandPath, arg)
	}

	restArgs := args[1+len(subcommandPath):]
	for idx, arg := range restArgs {
		if arg == "--" {
			arguments = append(arguments, restArgs[idx+1:]...)
			break
		}
		if strings.HasPrefix(arg, "-") {
			options = append(options, arg)
		} else {
			arguments = append(arguments, arg)
		}
	}

	return subcommandPath, options, arguments
}

func parseValue(typ string, strValue ...string) (dst any, err error) {
	switch typ {
	case "[]bool":
		val := make([]bool, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("bool", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []bool: %w", str, err)
			}
			val[idx] = v.(bool)
		}
		return val, nil
	case "[]int64":
		val := make([]int64, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("int64", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []int64: %w", str, err)
			}
			val[idx] = v.(int64)
		}
		return val, nil
	case "[]string":
		val := make([]string, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("string", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []string: %w", str, err)
			}
			val[idx] = v.(string)
		}
		return val, nil
	case "bool":
		switch strings.ToLower(strValue[0]) {
		default:
			return nil, fmt.Errorf("fail to parse %q as bool: unknown value", strValue[0])
		case "true", "1", "t":
			return true, nil
		case "false", "0", "f":
			return false, nil
		}
	case "int64":
		val, err := strconv.ParseInt(strValue[0], 0, 64)
		if err != nil {
			return nil, fmt.Errorf("fail to parse %q as int64: %w", strValue[0], err)
		}
		return val, nil
	case "string":
		return strValue[0], nil
	}

	return nil, fmt.Errorf("unknown type %q", typ)
}

func GetVersion() string {
	return ""
}
func GetProgram() string {
	return "goxe"
}
func GetDoc(subcommands []string) string {
	switch strings.Join(subcommands, " ") {
	case "":
		return "goxe \n\n    Syntax:\n        $ goxe \n\n    Subcommands:\n        build:\n\n        rewrite:\n\n        run:\n\n\n"

	case "build":
		return "goxe build\n\n    Syntax:\n        $ goxe build [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -go-build-args=<string>, -a=<string>  (default=\"\"):\n            Arguments to be passed to the go build command.\n            If not specified, the default arguments are used.\n\n    Arguments:\n        1. [<package:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten.\n\n\n"

	case "rewrite":
		return "goxe rewrite\n\n    Syntax:\n        $ goxe rewrite [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -output-directory=<string>, -o=<string>  (default=\"\"):\n            Output directory to place the rewritten source files of the package.\n            If not specified, the files are placed at a temporary directory.\n\n    Arguments:\n        1. [<package:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten.\n\n\n"

	case "run":
		return "goxe run\n\n    Syntax:\n        $ goxe run [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -go-run-args=<string>  (default=\"\"):\n\n    Arguments:\n        1. [<package_and_arguments:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten, followed by arguments to be passed to the main function.\n            If a local directory is given as the first argument, the rest of the arguments is treated as arguments to the main function.\n            If source files, each of which ends with '.go', are given as the first arguments, the rest of the arguments is treated as arguments to the main function.\n            Arguments after the first '--' are treated as arguments to the main function.\n            * Example 1:\n              goxe run /path/to/main/package arg1 arg2 --> package=/path/to/main/package, arguments=[arg1, arg2]\n            * Example 2:\n              goxe run ./path/to/main/package arg1 arg2 --> package=./path/to/main/package, arguments=[arg1, arg2]\n            * Example 3:\n              goxe run ./path/to/main/package -- arg1 arg2 --> package=./path/to/main/package, arguments=[arg1, arg2]\n            * Example 4:\n              goxe run ./source.go ./files.go ./arg.go arg1 arg2 --> package=[./source.go, ./files.go, ./arg.go], arguments=[arg1, arg2] \n            * Example 5:\n              goxe run ./source.go ./files.go -- ./arg.go arg1 arg2 --> package=[./source.go, ./files.go], arguments=[./arg.go, arg1, arg2] \n\n\n"
	default:
		panic(fmt.Sprintf(`invalid subcommands: %v`, subcommands))
	}
}
