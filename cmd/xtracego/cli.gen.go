// Code generated by cyamli, DO NOT EDIT.
package main

import (
	"fmt"
	"strconv"
	"strings"
)

type CLIHandler interface {
	Run(input Input) error
	Run_Build(input Input_Build) error
	Run_Rewrite(input Input_Rewrite) error
	Run_Run(input Input_Run) error
}

func Run(handler CLIHandler, args []string) error {
	subcommandPath, options, arguments := resolveArgs(args)
	switch strings.Join(subcommandPath, " ") {
	case "":
		var input Input
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run(input)

	case "build":
		var input Input_Build
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Build(input)

	case "rewrite":
		var input Input_Rewrite
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Rewrite(input)

	case "run":
		var input Input_Run
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Run(input)
	}
	return nil
}

type Input struct {
	Opt_TraceCall bool
	Opt_TraceCase bool
	Opt_TraceStmt bool
	Opt_TraceVar  bool
	Opt_Verbose   bool
	Subcommand    []string
	Options       []string
	Arguments     []string

	ErrorMessage string
}

func (input *Input) resolveInput(subcommand, options, arguments []string) {
	*input = Input{Opt_TraceCall: false,
		Opt_TraceCase: false,
		Opt_TraceStmt: false,
		Opt_TraceVar:  false,
		Opt_Verbose:   false,
		Subcommand:    subcommand,
		Options:       options,
		Arguments:     arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = v.(bool)
			}
		case "-no-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = !v.(bool)
			}

		case "-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = v.(bool)
			}
		case "-no-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = !v.(bool)
			}

		case "-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = v.(bool)
			}
		case "-no-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = !v.(bool)
			}

		case "-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = v.(bool)
			}
		case "-no-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = !v.(bool)
			}

		case "-verbose", "-v":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Verbose = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_Build struct {
	Opt_BuildDirectory string
	Opt_GoBuildArg     []string
	Opt_TraceCall      bool
	Opt_TraceCase      bool
	Opt_TraceStmt      bool
	Opt_TraceVar       bool
	Opt_Verbose        bool
	Arg_Package        []string
	Subcommand         []string
	Options            []string
	Arguments          []string

	ErrorMessage string
}

func (input *Input_Build) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Build{Opt_BuildDirectory: "",
		Opt_GoBuildArg: []string{},
		Opt_TraceCall:  false,
		Opt_TraceCase:  false,
		Opt_TraceStmt:  false,
		Opt_TraceVar:   false,
		Opt_Verbose:    false,
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-build-directory", "-o":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_BuildDirectory = v.(string)
			}

		case "-go-build-arg", "-a":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("[]string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_GoBuildArg = append(input.Opt_GoBuildArg, v.([]string)[0])
			}

		case "-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = v.(bool)
			}
		case "-no-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = !v.(bool)
			}

		case "-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = v.(bool)
			}
		case "-no-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = !v.(bool)
			}

		case "-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = v.(bool)
			}
		case "-no-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = !v.(bool)
			}

		case "-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = v.(bool)
			}
		case "-no-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = !v.(bool)
			}

		case "-verbose", "-v":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Verbose = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_Package = v.([]string)
	}
}

type Input_Rewrite struct {
	Opt_OutputDirectory string
	Opt_TraceCall       bool
	Opt_TraceCase       bool
	Opt_TraceStmt       bool
	Opt_TraceVar        bool
	Opt_Verbose         bool
	Arg_Package         []string
	Subcommand          []string
	Options             []string
	Arguments           []string

	ErrorMessage string
}

func (input *Input_Rewrite) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Rewrite{Opt_OutputDirectory: "",
		Opt_TraceCall: false,
		Opt_TraceCase: false,
		Opt_TraceStmt: false,
		Opt_TraceVar:  false,
		Opt_Verbose:   false,
		Subcommand:    subcommand,
		Options:       options,
		Arguments:     arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-output-directory", "-o":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutputDirectory = v.(string)
			}

		case "-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = v.(bool)
			}
		case "-no-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = !v.(bool)
			}

		case "-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = v.(bool)
			}
		case "-no-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = !v.(bool)
			}

		case "-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = v.(bool)
			}
		case "-no-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = !v.(bool)
			}

		case "-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = v.(bool)
			}
		case "-no-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = !v.(bool)
			}

		case "-verbose", "-v":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Verbose = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_Package = v.([]string)
	}
}

type Input_Run struct {
	Opt_GoBuildArg          []string
	Opt_TraceCall           bool
	Opt_TraceCase           bool
	Opt_TraceStmt           bool
	Opt_TraceVar            bool
	Opt_Verbose             bool
	Arg_PackageAndArguments []string
	Subcommand              []string
	Options                 []string
	Arguments               []string

	ErrorMessage string
}

func (input *Input_Run) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Run{Opt_GoBuildArg: []string{},
		Opt_TraceCall: false,
		Opt_TraceCase: false,
		Opt_TraceStmt: false,
		Opt_TraceVar:  false,
		Opt_Verbose:   false,
		Subcommand:    subcommand,
		Options:       options,
		Arguments:     arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-go-build-arg", "-a":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("[]string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_GoBuildArg = append(input.Opt_GoBuildArg, v.([]string)[0])
			}

		case "-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = v.(bool)
			}
		case "-no-trace-call":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCall = !v.(bool)
			}

		case "-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = v.(bool)
			}
		case "-no-trace-case":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceCase = !v.(bool)
			}

		case "-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = v.(bool)
			}
		case "-no-trace-stmt":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceStmt = !v.(bool)
			}

		case "-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = v.(bool)
			}
		case "-no-trace-var":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_TraceVar = !v.(bool)
			}

		case "-verbose", "-v":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Verbose = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 1
	func(...any) {}(expectedArgs)
	if len(input.Arguments) < 0 {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}

	if v, err := parseValue("[]string", input.Arguments[0:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[0:], " "), 0)
		return
	} else {
		input.Arg_PackageAndArguments = v.([]string)
	}
}
func resolveArgs(args []string) (subcommandPath []string, options []string, arguments []string) {
	if len(args) == 0 {
		panic("command line arguments are too few")
	}
	subcommandSet := map[string]bool{
		"": true, "build": true, "rewrite": true, "run": true,
	}

	subcommandPath, options, arguments = []string{}, []string{}, []string{}
	for _, arg := range args[1:] {
		if arg == "--" {
			break
		}
		pathLiteral := strings.Join(append(append([]string{}, subcommandPath...), arg), " ")
		if !subcommandSet[pathLiteral] {
			break
		}
		subcommandPath = append(subcommandPath, arg)
	}

	restArgs := args[1+len(subcommandPath):]
	for idx, arg := range restArgs {
		if arg == "--" {
			arguments = append(arguments, restArgs[idx+1:]...)
			break
		}
		if strings.HasPrefix(arg, "-") {
			options = append(options, arg)
		} else {
			arguments = append(arguments, arg)
		}
	}

	return subcommandPath, options, arguments
}

func parseValue(typ string, strValue ...string) (dst any, err error) {
	switch typ {
	case "[]bool":
		val := make([]bool, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("bool", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []bool: %w", str, err)
			}
			val[idx] = v.(bool)
		}
		return val, nil
	case "[]int64":
		val := make([]int64, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("int64", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []int64: %w", str, err)
			}
			val[idx] = v.(int64)
		}
		return val, nil
	case "[]string":
		val := make([]string, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("string", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []string: %w", str, err)
			}
			val[idx] = v.(string)
		}
		return val, nil
	case "bool":
		switch strings.ToLower(strValue[0]) {
		default:
			return nil, fmt.Errorf("fail to parse %q as bool: unknown value", strValue[0])
		case "true", "1", "t":
			return true, nil
		case "false", "0", "f":
			return false, nil
		}
	case "int64":
		val, err := strconv.ParseInt(strValue[0], 0, 64)
		if err != nil {
			return nil, fmt.Errorf("fail to parse %q as int64: %w", strValue[0], err)
		}
		return val, nil
	case "string":
		return strValue[0], nil
	}

	return nil, fmt.Errorf("unknown type %q", typ)
}

func GetVersion() string {
	return ""
}
func GetProgram() string {
	return "xtracego"
}
func GetDoc(subcommands []string) string {
	switch strings.Join(subcommands, " ") {
	case "":
		return "xtracego \n\n    Syntax:\n        $ xtracego  [<option>]...\n\n    Options:\n        -trace-call[=<boolean>]  (default=false),\n        -no-trace-call[=<boolean>]:\n            Whether trace calling functions and methods or not.\n\n        -trace-case[=<boolean>]  (default=false),\n        -no-trace-case[=<boolean>]:\n            Whether trace cases of switch and select statements or not.\n\n        -trace-stmt[=<boolean>]  (default=false),\n        -no-trace-stmt[=<boolean>]:\n            Whether trace basic statements or not.\n\n        -trace-var[=<boolean>]  (default=false),\n        -no-trace-var[=<boolean>]:\n            Whether trace variables and constants or not.\n\n        -verbose[=<boolean>], -v[=<boolean>]  (default=false):\n            Whether to output verbose messages or not.\n\n    Subcommands:\n        build:\n            Rewrites the source files in the specified package and places these files in the build directory.\n            Executes go build at the specified directory with the given arguments.\n\n        rewrite:\n            Rewrites the source files in the specified package and places these files in the output directory.\n            The rewritten files includes Go code to log trace information.\n            If go.mod of the module of the package is found, it is copied to the output directory.\n\n        run:\n            Rewrites the source files in the specified package and places these files in a temporary directory.\n            Executes go build at the temporary directory with the given arguments.\n            Thereafter, the built executable file is executed at the current working directory.\n\n\n"

	case "build":
		return "xtracego build\n\n    Description:\n        Rewrites the source files in the specified package and places these files in the build directory.\n        Executes go build at the specified directory with the given arguments.\n\n    Syntax:\n        $ xtracego build [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -build-directory=<string>, -o=<string>  (default=\"\"):\n            The source files included the specified package are rewritten and placed in this directory which is used as a current working directory to execute go build.\n            This option is required.\n\n        -go-build-arg=<string>, -a=<string>  (default=\"\"):\n            Arguments to be passed to the go build command.\n            If there are multiple arguments for go build, this option can be specified multiple times.\n\n        -trace-call[=<boolean>]  (default=false),\n        -no-trace-call[=<boolean>]:\n            Whether trace calling functions and methods or not.\n\n        -trace-case[=<boolean>]  (default=false),\n        -no-trace-case[=<boolean>]:\n            Whether trace cases of switch and select statements or not.\n\n        -trace-stmt[=<boolean>]  (default=false),\n        -no-trace-stmt[=<boolean>]:\n            Whether trace basic statements or not.\n\n        -trace-var[=<boolean>]  (default=false),\n        -no-trace-var[=<boolean>]:\n            Whether trace variables and constants or not.\n\n        -verbose[=<boolean>], -v[=<boolean>]  (default=false):\n            Whether to output verbose messages or not.\n\n    Arguments:\n        1. [<package:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten.\n\n\n"

	case "rewrite":
		return "xtracego rewrite\n\n    Description:\n        Rewrites the source files in the specified package and places these files in the output directory.\n        The rewritten files includes Go code to log trace information.\n        If go.mod of the module of the package is found, it is copied to the output directory.\n\n    Syntax:\n        $ xtracego rewrite [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -output-directory=<string>, -o=<string>  (default=\"\"):\n            Output directory to place the rewritten source files of the package.\n            This option is required.\n\n        -trace-call[=<boolean>]  (default=false),\n        -no-trace-call[=<boolean>]:\n            Whether trace calling functions and methods or not.\n\n        -trace-case[=<boolean>]  (default=false),\n        -no-trace-case[=<boolean>]:\n            Whether trace cases of switch and select statements or not.\n\n        -trace-stmt[=<boolean>]  (default=false),\n        -no-trace-stmt[=<boolean>]:\n            Whether trace basic statements or not.\n\n        -trace-var[=<boolean>]  (default=false),\n        -no-trace-var[=<boolean>]:\n            Whether trace variables and constants or not.\n\n        -verbose[=<boolean>], -v[=<boolean>]  (default=false):\n            Whether to output verbose messages or not.\n\n    Arguments:\n        1. [<package:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten.\n\n\n"

	case "run":
		return "xtracego run\n\n    Description:\n        Rewrites the source files in the specified package and places these files in a temporary directory.\n        Executes go build at the temporary directory with the given arguments.\n        Thereafter, the built executable file is executed at the current working directory.\n\n    Syntax:\n        $ xtracego run [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -go-build-arg=<string>, -a=<string>  (default=\"\"):\n            Arguments to be passed to the go run command.\n            If there are multiple arguments for go build, this option can be specified multiple times.\n\n        -trace-call[=<boolean>]  (default=false),\n        -no-trace-call[=<boolean>]:\n            Whether trace calling functions and methods or not.\n\n        -trace-case[=<boolean>]  (default=false),\n        -no-trace-case[=<boolean>]:\n            Whether trace cases of switch and select statements or not.\n\n        -trace-stmt[=<boolean>]  (default=false),\n        -no-trace-stmt[=<boolean>]:\n            Whether trace basic statements or not.\n\n        -trace-var[=<boolean>]  (default=false),\n        -no-trace-var[=<boolean>]:\n            Whether trace variables and constants or not.\n\n        -verbose[=<boolean>], -v[=<boolean>]  (default=false):\n            Whether to output verbose messages or not.\n\n    Arguments:\n        1. [<package_and_arguments:string>]...\n            Path to a local directory of the main package or paths to source files in the package to be rewritten, followed by arguments to be passed to the main function.\n            If a local directory is given as the first argument, the rest of the arguments is treated as arguments to the main function.\n            If source files, each of which ends with '.go', are given as the first arguments, the rest of the arguments is treated as arguments to the main function.\n            Arguments after the first '--' are treated as arguments to the main function.\n            * Example 1:\n              xtracego run /path/to/main/package arg1 arg2 --> package=/path/to/main/package, arguments=[arg1, arg2]\n            * Example 2:\n              xtracego run ./path/to/main/package arg1 arg2 --> package=./path/to/main/package, arguments=[arg1, arg2]\n            * Example 3:\n              xtracego run ./path/to/main/package -- arg1 arg2 --> package=./path/to/main/package, arguments=[arg1, arg2]\n            * Example 4:\n              xtracego run ./source.go ./files.go ./arg.go arg1 arg2 --> package=[./source.go, ./files.go, ./arg.go], arguments=[arg1, arg2] \n            * Example 5:\n              xtracego run ./source.go ./files.go -- ./arg.go arg1 arg2 --> package=[./source.go, ./files.go], arguments=[./arg.go, arg1, arg2] \n\n\n"
	default:
		panic(fmt.Sprintf(`invalid subcommands: %v`, subcommands))
	}
}
